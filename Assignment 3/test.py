# -*- coding: utf-8 -*-
"""test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JfkeJfrx_hRExnODckW83viY0KqFlZ2W
"""

import unittest
import pickle
from score import score

import sklearn
import numpy as np
import pandas as pd
import random

test=pd.read_csv(r"C:\Users\Samriddha\OneDrive\Desktop\msc@cmi\cmi sem 4\Applied ML\test.csv")

import random

# Generate a random integer between a specified range (inclusive)
r = random.randint(0, 573)#number of rows in train.csv is 573

text= test.iat[r,0]

# text

import unittest
import pickle
import pandas as pd
from score import score

class TestScoreFunction(unittest.TestCase):

    def setUp(self):
        # Load your trained model for testing
        # Replace 'best_model.pkl' with the actual filename of your saved model
        with open(r"C:\Users\Samriddha\OneDrive\Desktop\msc@cmi\cmi sem 4\Applied ML\best_model.pkl", 'rb') as model_file:
            self.loaded_model = pickle.load(model_file)

        # Load input texts from the CSV file
        self.test_df = pd.read_csv(r"C:\Users\Samriddha\OneDrive\Desktop\msc@cmi\cmi sem 4\Applied ML\test.csv")


    def test_smoke_test(self):
        # Smoke test: Check if the function runs without crashing
            # Generate a random integer between a specified range (inclusive)
            r = random.randint(0, 573)#number of rows in train.csv is 573

            text= test.iat[r,0]
            result = score(text, self.loaded_model, 0.5)
            self.assertIsNotNone(result)

    def test_format_test(self):
        # Format test: Check if the output formats/types are as expected
        # Generate a random integer between a specified range (inclusive)
            r = random.randint(0, 573)#number of rows in train.csv is 573

            text= test.iat[r,0]
            prediction, propensity = score(text, self.loaded_model, 0.5)
            # print(f"Text: {text}, Prediction: {prediction}, Propensity: {propensity}")
            # print(f"Type of Prediction: {type(prediction)}")
            self.assertIsInstance(prediction, (bool, np.bool_))
            self.assertIsInstance(propensity, float)

    def test_prediction_values(self):
        # Check if prediction values are 0 or 1
        # Generate a random integer between a specified range (inclusive)
            r = random.randint(0, 573)#number of rows in train.csv is 573

            text= test.iat[r,0]
            prediction, _ = score(text, self.loaded_model, 0.5)
            self.assertTrue(prediction in [0, 1])

    def test_propensity_range(self):
        # Check if propensity score is between 0 and 1
        # Generate a random integer between a specified range (inclusive)
            r = random.randint(0, 573)#number of rows in train.csv is 573

            text= test.iat[r,0]
            _, propensity = score(text, self.loaded_model, 0.5)
            self.assertTrue(0 <= propensity <= 1)

    def test_threshold_zero(self):
        # Test if setting the threshold to 0 always produces prediction as 1
        # Generate a random integer between a specified range (inclusive)
            r = random.randint(0, 573)#number of rows in train.csv is 573

            text= test.iat[r,0]
            prediction, _ = score(text, self.loaded_model, 0.0)
            self.assertTrue(prediction)

    def test_threshold_one(self):
        # Test if setting the threshold to 1 always produces prediction as 0
        # Generate a random integer between a specified range (inclusive)
            r = random.randint(0, 573)#number of rows in train.csv is 573

            text= test.iat[r,0]
            prediction, _ = score(text, self.loaded_model, 1.0)
            self.assertFalse(prediction)

    def test_obvious_spam_input(self):
        # Test if an obvious spam input text results in prediction as 1
            text=test.iat[0,0]
            prediction, _ = score(text, self.loaded_model, 0.5)
            self.assertTrue(prediction)

    def test_obvious_non_spam_input(self):
        # Test if an obvious non-spam input text results in prediction as 0
            text=test.iat[2,0]
            prediction, _ = score(text, self.loaded_model, 0.5)
            self.assertFalse(prediction)

if __name__ == '__main__':
    unittest.main()

import unittest
import os
import subprocess
import requests

class TestFlaskIntegration(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        # Start the Flask app in a separate process
        cls.flask_process = subprocess.Popen(['python', 'app.py'])

    @classmethod
    def tearDownClass(cls):
        # Terminate the Flask app process
        cls.flask_process.terminate()

    def test_flask_endpoint(self):
        # Define the endpoint URL
        endpoint_url = 'http://127.0.0.1:5000/score'

        # Prepare the request data
        data = {
            'text': text,
            'threshold': 0.5
        }

        # Send a POST request to the Flask app
        response = requests.post(endpoint_url, json=data)

        # Check the status code
        self.assertEqual(response.status_code, 200)

        # Parse the response JSON
        response_json = response.json()

        # Check the keys in the response
        self.assertIn('prediction', response_json)
        self.assertIn('propensity', response_json)

        # Optionally, add more assertions based on your expected response format

if __name__ == '__main__':
    unittest.main()